(* -*- compile-command: "ocamlbuild -classic-display fulltrees.pdf" -*- *)

open Prelude
open Ocamlmode


##plugin coqdoc
##verbatim '@' = coqdoc
##verbatim '#' = ocaml_code

(*** labels ***)

let s_algo = label ()
let s_ocaml = label ()
let s_coq = label ()

(*** doc ***)
let abstract = "Starting with an algorithm to turn lists into full trees which uses non-obvious invariants and partial functions, we progressively encode the invariants in the types of the data, removing most of the burden of a correctness proof.

The invariants are encoded using non-uniform inductive types which parallel numerical representations in a style advertised by Okasaki, and a small amount of dependent types."

let intro = "{section"Introduction"}

Starting with a list <#l#>, we want to turn it into a binary tree <#t#> of the following form (in Ocaml):

{display"<#type 'a tree =
  | Node of 'a tree * 'a * 'a tree
  | Leaf#>"}

With the constraints that <#l#> must be the infix traversal of <#t#> and that <#t#> must be {emph"full"}, in the sense that every level except the last are required to be completely filled. Such a function turns, in particular, sorted list into balanced binary search trees.

There is a number of algorithms to achieve this result in linear time. Here we consider an algorithm, presented in Section~{ref_ s_algo}, which repeatedly pairs up trees of height $h$ in a list to form a list of trees of height $h+1$. Our interest in this algorithm sprouts from the fact that its correctness is not obvious; in particular the invariants are complex: the main loop operates on a list of size $2^n-1$ whose elements are full trees whose height is alternatively a given $h$ and $1$.

In Sections~{ref_ s_ocaml} and~{ref_ s_coq} we show refinements of the algorithm where the invariants are pushed into the types, leading to a complete and short proof of correctness in Coq.
"

let algo = "{section"A balancing algorithm" ~label:s_algo}
Sample Ocaml code:
\\
<#let f x = x+3 in
  match f 2 with
  | 3 -> true
  | false#>
"

let ocaml = "{section"Removing partial functions" ~label:s_ocaml}

(* arnaud: make more precise when the previous section is written and has names for things *)
(* arnaud: it's not entirely true that the size invariant is preserved during the main loop, it is an invariant of the external "pass" loop, but not the internal "pairing" loop, which certainly does not make things easier. *)
The functions of Section~{ref_ s_algo} rely on the fact that the following invariant holds throughout the main loop: the list has size $2^n-1$ for some $n$ and is non-empty, and all the even-position elements (counting from $1$) are singleton trees.

Yet it is not immediately apparent that these properties hold. If it does not take a tremendous effort to convince oneself that the <#balance#> function of Section~{ref_ s_algo} is indeed correct, a direct mechanically checked proof would not be very practical.

{subsection"Size invariants"}

Let us turn to representing non-empty lists of size $2^n-1$. There is a well-known data structure which holds $2^n-1$ values: complete binary trees of height $n$. But given that trees are already what our algorithm builds, it is unlikely that complete binary trees are the appropriate structure for the loop.

Instead, let us consider the following recursive definition of $2^n-1$:
{displaymath begin just_left `Brace (array [`L;`L;`L] [
  array_line [$2^1-1$; $=$ ; $1$];
  array_line [${exponent $2$ $n+1$}-1$; $=$; $2 {times} (2^n-1)+1$];
]) end}
Which is just a fancy way of saying that the $2^n-1$ are precisely those number which are written only with $1$-s in binary representation. In general, given a reasonable representation of (a subset of) the natural numbers, a corresponding structurally recursive definition of exponential can be deduced:
{displaymath begin just_left `Brace (array [`L;`L;`L] [
  array_line [exponent $a$ $2^1-1$; $=$ ; $a$];
  array_line [exponent $a$ ${exponent $2$ $n+1$}-1$; $=$; $a*{exponent $(a^2)$ $2^n-1$}$];
]) end}
If $a$ is read as a type, then $a^n$, is nothing but the type of lists of length $n$ filled with elements of $a$. Depending on the algorithm used to compute the exponential, one gets a different flavour of list. The standard linked lists correspond to the na√Øve algorithm ${exponent $a$ $n+1$}=a*a^n$, which is associated with the unary representation of numbers. Using the algorithm above, we restrict the lists to have size $2^n$ and the shape is more unusual. Generalising to an arbitrary $n$, we obtain the (non-uniformly recursive) datatype, which we shall call {emph"power lists"}:
{display"<#module PowerList = struct

  type 'a t =
    | One of 'a
    | TwicePlusOne of 'a * ('a*'a) t

end#>"}

The correspondence between flavours of lists and numerical representation goes back to Guibas \& al. in~{cite"Guibas1977"} and is pushed further by Myers in~{cite"Myers1983"}. A thorough exploration of the correspondence, is conducted by Okasaki in~{cite"Okasaki1999"}(*arnaud: add relevant chapters*) where he introduces the idea of using non-uniform inductive datatypes in the context of numerical representations. As a matter of fact, the type of power lists actually appears in~{cite"Okasaki1999"} as a pedagogical introduction to non-uniformly recursive lists. With numerical representations which cover the whole set of natural numbers, we obtain lists with unusual shapes but which can have any number of elements. We will return to these in Section~{ref_ s_coq}.

Although the power lists may look like some sort of trees, it is not a very accurate depiction. The easiest way to picture how power lists works is to see <#TwicePlusOne#> as a fancy <#(::)#>, then the lists with, respectively, $1$, $3$, $7$, and $15$ elements are as follows:
{itemize [
  "<#[1]#>";
  "<#[1;(2,3)]#>";
  "<#[1;(2,3);((4,5),(6,7))]#>";
  "<#[1;(2,3);((4,5),(6,7));(((8,9),(10,11)),((12,13),(14,15)))]#>";
 ]}
Elements appear in order, like in a list, but they are packed twice as tightly after each <#TwicePlusOne#>.

Just like with regular lists, there is a {emph"map"} function for power lists. Due to the non-uniformity it is a little trickier{footnote"The type annotation on <#PowerList.map#> informs Ocaml that <#map#> is a non-uniform recursive function. Without the type annotation, Ocaml simply assumes that <#map#> is uniformly recursive and fails to typecheck since <#f#> and <#f'#> have different types."} than the regular list map: in the recursive steps, the argument function <#f#> needs to process two consecutive elements at a time.
{display"<#module PowerList = struct

  #{module_elipsis}#

  let rec map : 'a 'b. ('a->'b) -> 'a t -> 'b t = fun f l ->
    match l with
    | One x -> One (f x)
    | TwicePlusOne (x,l) ->
        let f' (x,y) = f x , f y in
        TwicePlusOne ( f x , map f' l)

end#>"}

{subsection"Alternation"}

In Section~{ref_ s_algo}, we encode elements as singleton trees, relying on the <#root#> function to extract the value from the tree. If the invariant that even-position elements are actually singleton, <#root#> can fail if the applied to an empty tree, or lose elements if applied to a bigger tree.

In this section, instead, we consider a variant of <#'a PowerList.t#> where every odd position is a tree, and every even position an element. More generally, we define a type <#('odd,'even) AlternatingPowerList.t#> where odd positions have type <#'odd#>, and even positions have type <#'even#>. Such a list should have the following pattern:
{itemize [
  "<#['odd;('even,'odd);(('even,'odd),('even,'odd))#>";
]}
After the first element, which must have type <#'odd#>, there is no difference between even and odd position: indeed, removing the first element, we actually have an <#('even*'odd) PowerList.t#>. Hence the definition:
{display"<#module AlternatingPowerList = struct
  type ('odd,'even) t =
    | One of 'odd
    | TwicePlusOne of 'odd * ('even*'odd) PowerList.t

end#>"}

We can now define the main loop of our algorithm. The important remark is that in Section~{ref_ s_algo}, the elements are processed four by four: three are joined into a tree, and the last is left as a future root. After two constructors, the elements of an <#('odd,'even) AlternatingPowerList.t#> are grouped by four: an <#('odd,'even) AlternatingPowerList.t#> of length ${exponent $2$ $n+2$}-1$ is -- abusing notations a little -- of the form <#TwicePlusOne a (TwicePlusOne (b,c) l#>, where <#l#> has type <#(('even*'odd)*('even*'odd)) PowerList.t#>. As a consequence, the inner loop is essentially a <#PowerList.map#>.

Writing <#PL#> and <#APL#> for <#PowerList#> and <#AlternatingPowerList#> respectively, we define the function <#pass:'a tree -> ('a*'a tree) PL.t -> ('a tree,'a) APL.t#>, which joins the trees in a list of length ${exponent $2$ $n+1$}-1$ (represented as the two arguments of the <#TwicePlusOne#> constructor), producing a list of length $2^n-1$, and the function <#balance_powerlist:('a tree,'a) APL.t -> 'a tree#> which iterates <#pass#> until there is a single tree left and returns it:
{display"<#let pass t l =
    match l with
    | PL.One (a,s) -> APL.One (Node(t,a,s))
    | PL.TwicePlusOne((a,s),l) ->
        APL.TwicePlusOne ( Node(t,a,s) ,
                           PL.map (fun ((a,t),(b,s)) -> a , Node(t,b,s) ) l )

let rec balance_powerlist = function
  | APL.One t -> t
  | APL.TwicePlusOne (t,l) ->
      balance_powerlist (pass t l)#>"}

{subsection"Padding"}

There is no partial function in the code of <#balance_powerlist#>, but we have not achieved our goal yet: we want to turn any list into a tree. Like in Section~{ref_ s_algo} we will use an initialisation phase, were we will pad our list with empty trees to reach a length of $2^n-1$. The output of this initialisation will be a <#('a tree,'a) APL.t#>.

The heart of this section is a function which turns a non-empty list of <#'a#> into an <#('a*'a tree) PowerList.t#>. The final function, which produces an <#('a tree,'a) AlternatingPowerList.t#> is a thing wrapper around the former. The idea here is to represent the non-empty list in a way that makes its {emph"parity"} apparent. Such a type is <#('a*'a) list#>: the type of lists of even length. For a general list, there is a loose element (which we choose to be the first) when it has odd length, leading to the type <#'a option * ('a*'a) list#>. But the latter type may contains the empty list, to prevent this, we keep the {emph"two first"} apart when the list has even length, so our type of non-empty lists is <#'a eo * ('a*'a) list#>, where <#'a eo#> is the following type:
{display"<#type 'a eo =
  | Odd of 'a
  | Even of ('a*'a)#>"}

We can fold a non-empty list into a <#'a eo * ('a*'a) list#> with the function <#pair_up: 'a -> 'a list -> 'a eo * ('a*'a) list#>:
{display"<#let rec pair_up hd = function
  | [] -> Odd hd , []
  | b::l ->
      begin match pair_up b l with
      | Even bc,l' -> Odd hd , bc::l'
      | Odd b,l' -> Even (hd,b) , l'
      end#>"}

Finally, abstracting the return type for recursion, we can write:
{display"<#module PowerList = struct

  #{module_elipsis}#

  let rec of_ne_list : 'a 'b. ('a->'b) -> ('a*'a->'b) -> 'a eo -> ('a*'a) list -> 'b t =
    fun d f a l ->
      let cast = function
        | Odd x -> d x
        | Even (x,y) -> f (x,y)
      in
      match l with
      | [] -> One (cast a)
      | b::l ->
          let d' (x,y) = (d x , d y) in
          let f' (x,y) = (f x , f y) in
          let (b',l') = pair_up b l in
          TwicePlusOne ( cast a , of_ne_list d' f' b' l' )
end#>"}
Where <#cast#> witnesses that <#d#> and <#f#> together form a function <#'a eo -> 'b#>. We could have used such a function as an argument, but because of the recursive step, it would actually have been more verbose. Notice how every recursive step has a call to <#pair_up#>, to keep up with the non-uniform inductive definition of <#'a PowerList.t#>.

With that function, we can conclude our implementation. Again writing <#PL#> and <#APL#> for <#PowerList#> and <#AlternatingPowerList#> respectively:

{display"<#module AlternatingPowerList = struct

  #{module_elipsis}#

  let of_list d f g = function
    | [] -> One d
    | [a] -> One (f a)
    | a::b::l ->
        let d' x = g x , d in
        let fg (x,y) = g x , f y in
        let (b',l') = PowerList.pair_up b l in
        TwicePlusOne ( f a , PowerList.of_ne_list d' fg b' l')

end

let singleton x = Node(Leaf,x,Leaf)
let balance l =
  balance_powerlist (APL.of_list Leaf singleton (fun e->e) l) #>"}
The final function, <#balance:'a list -> 'a tree#>, indeed implements the algorithm of Section~{ref_ s_algo} without any partial functions.
"

let coq = "{section"Turning to Coq" ~label:s_coq}

There is still a non-obvious property of the algorithm that the implementation of Section~{ref_ s_ocaml} does not make obvious: that the algorithm actually does build {emph"full"} trees. In this section we shall build into the type of <@balance@> that its output is indeed full.

To that effect, we will use Coq rather than Ocaml. Even if it is possible, with some effort, to represent full trees and implement the algorithm in Ocaml -- and relatively easy in Haskell -- a Coq implementation also gives us termination by construction. Coq forces every recursion to be structural, which will prove to be rather entertaining.

At a superficial level, a visible difference with the Ocaml implementation is that <#Powerlist.t#> and <#AlternatingPowerList.t#> must be decorated with the $n$ such that the length is $2^n-1$: it is the structural recursion parameter of the <@balance_powerlist@> function. Because it makes the code simpler, we will use a recursive definition rather than an inductive one:
{display"<@Module PowerList.

  Fixpoint T (A:Type) (n:nat) :=
    match n with
    | 0 => A
    | S n' => (A * T (A*A) n')%type
    end
  .

End PowerList.@>"}
We will also need a version where the height is kept implicit. For that purpose we use Coq's type of dependent pairs <@{ n:nat & F n}@>. The constructor for dependent pairs is written <@‚ü® F , n , x ‚ü©@>. The implicit version comes with constructors -- <@tpo@> stands for ``twice plus one'':
{display"<@Module PowerList.

  @{module_elipsis}@

  Definition U (A:Type) := { n:nat & T A n }.
  Definition one {A:Type} (a:A) : U A := ‚ü® T A , 0 , a ‚ü©.
  Definition tpo {A:Type} (a:A) (l:U (A*A)) : U A :=
    let '(existT n  l) := l in
    ‚ü® T A , S n , (a,l) ‚ü©.

End PowerList.@>"}
The definition of <@AlternatingPowerList.T@> and <@AlternatingPowerList.U@> are similar.

{subsection"Full trees"}

To code full trees, we index trees by their height, and specify that leaves can happen only at height $0$ or $1$:
{display"<@Inductive FullTree (A:Type) : nat -> Type :=
  | Leaf‚ÇÄ : FullTree A 0
  | Leaf‚ÇÅ : FullTree A 1
  | Node {n:nat} : FullTree A n -> A -> FullTree A n -> FullTree A (S n)
.@>"}

With this modification, the functions <@pass@> and <@balance_powerlist@> are virtually unmodified with respect to Section~{ref_ s_ocaml}. Only their types change to reflect the extra information:
{display"<@Definition pass {A n p} : APL.T (FullTree A (S p)) A (S n) -> APL.T (FullTree A (S (S p))) A n.
Fixpoint balance_powerlist {A n p} : APL.T (FullTree A (S p)) A n -> FullTree A (plus n (S p)) {struct n}.@>"}
The algorithm indeed builds only full trees.

{subsection"Structural initialisation"}

The padding conversion from lists to lists of size $2^n-1$ is not structural, due to the use of <#pair_up#> in the recursive call. We will need another intermediate structure: it must be isomorphic to the type of list, but it must conform with the structure of <@PowerList.of_ne_list@>. That is, we want a datatype such that $"<@'a t@>"="<@'a eo * 'a t@>"$. As it turns out, this is a good definition, and it is a non-uniform datatype which corresponds to a numerical representation.

Indeed, we can write any non-zero natural number in binary with digits $1$ and $2$ (but not $0$). In this system, for example, $8$ is represented as $112$. Here is the definition:
{display"<@Module BinaryList.

  Inductive T (A:Type) : Type :=
  | one (a:A)
  | two (a b:A)
  | tpo (a:A) (l:T (A*A))
  | tpt (a b: A) (l:T (A*A))
  .

End BinaryList.@>"}

To turn a non-empty list into a <@BinaryList.T@>, all we need is a function <@cons:A -> T A -> T A@> to add an element in front of the list. On the numerical representation side, it corresponds to adding $1$. It behaves like adding $1$ in the usual binary representation, except that $1$-s are turned into $2$-s without a carry and $2$-s into $1$-s while producing a carry:
{display"<@Module BinaryList.

  @{module_elipsis}@

  Fixpoint cons {A} (a:A) (l:T A) : T A :=
    match l with
    | one b => two a b
    | two b c => tpo a (one (b,c))
    | tpo b l => tpt a b l
    | tpt b c l => tpo a (cons (b,c) l)
    end
  .

End BinaryList.@>"}
Note that while <@cons@> takes, in the worst case, logarithmic time with respect to the length of the list, building a list by repeatedly using <@cons@> is still linear. (*arnaud: guyslain should help me give a good explanation here. *)

We also need a function which turns a <@T (A*A)@> into a <@T A@>. This is effectively multiplication by $2$. The lack of $0$ among the digits makes this process recursive:
{displaymath begin just_left `Brace (array [`L;`L;`L] [
  array_line [$x20$ ; $=$ ; $x12$];
  array_line [$x10$ ; $=$; $x02$];
]) end}
In terms of binary lists:
{display"<@Module BinaryList.

  @{module_elipsis}@

  Fixpoint twice {A} (l:T (A*A)) : T A :=
    match l with
    | one (a,b) => two a b
    | two (a,b) cd => tpt a b (one cd)
    | tpo (a,b) l => tpt a b (twice l)
    | tpt (a,b) cd l => tpt a b (tpo cd l)
    end
  .

End BinaryList.@>"}

We can now write a structurally recursive <#PowerList.of_ne_list#>, using binary lists as the structural argument. Notice that, as we do not know in advance the size of the produced list, a <@PowerList.U@> is returned:
{display"<@Module PowerList.

  @{module_elipsis}@

  Fixpoint of_binary_list {A X} (d:A->X) (f:A*A->X) (l:BL.T A) : U X :=
    match l with
    | BL.one a => one (d a)
    | BL.two a b => one (f (a,b))
    | BL.tpo a l =>
      tpo (d a) (of_binary_list (d√ód) (f√óf) l)
    | BL.tpt a b l =>
      tpo (f (a,b)) (of_binary_list (d√ód) (f√óf) l)
    end
  .

End PowerList.@>"}
Where <@g√óf@> is the function which maps <@(x,y)@> to <@(g x,f y)@>.

The rest follows straightforwardly, and we can define the following functions which conclude the algorithm (<@BL@>, <@PL@>, and <@APL@> stand for <@BinaryList@>, <@PowerList@>, and <@AlternatingPowerList@> respectively):
{display"<@Module AlternatingPowerList.

  @{module_elipsis}@

  Definition of_binary_list {A Odd Even} (d:Odd) (f:A->Odd) (g:A->Even) (l:BL.T A) : U Odd Even.

  Definition of_list {A Odd Even} (d:Odd) (f:A->Odd) (g:A->Even) (l:list A) : U Odd Even.

End AlternatingPowerList.


Definition balance {A:Type} (l:list A) : { n:nat & FullTree A n }.@>"}
"

let concl = "{section"Conclusion"}

The <@balance@> function of Section~{ref_ s_coq} is, by virtue of its type alone, a total function which turns lists into full binary trees. Yet, to the cost of using intermediary data-structures, it effectively implements the algorithm of Section~{ref_ s_algo}.

The missing piece is to prove that the infix traversal of <@balance l@> is indeed <@l@>. The infix traversal of a (full) tree is represented in Coq with the functions
{display"<@Fixpoint list_of_full_tree_n {A n} (t:FullTree A n) : list A :=
  match t with
  | Leaf‚ÇÄ => []
  | Leaf‚ÇÅ => []
  | Node _ t‚ÇÅ x t‚ÇÇ => list_of_full_tree_n t‚ÇÅ ++ [x] ++ list_of_full_tree_n t‚ÇÇ
  end
.

Definition list_of_full_tree {A} (t:{ n:nat & FullTree A n }) : list A :=
  list_of_full_tree_n (projT2 t)
.@>"}
We can then state the theorem:
{display"<@Theorem balance_preserves_order A (l:list A) : list_of_full_tree (balance l) = l.@>"}

The proof is short and straightforward: we define a traversal function for each intermediate structure; and state a variant of <@balance_preserves_order@> for each intermediate function. Proving the intermediate lemmas is not difficult and can be mostly automatised: we use a very simple generic automated tactic, which discharges most goals. This theorem concludes our easy formal proof of the balancing algorithm.
"

let d = concat [
  intro;
  algo;
  ocaml;
  coq;
  concl;
  command \"bibliography\" [A,"library"] A;
]

(*** metadata ***)

open Llncs

let inria = new_institution "Inria Paris-Rocquencourt\\{textsc"Ens"}, 45 rue d'Ulm,
 75230 Paris Cedex 05, France"
let amu = new_institution "Aix-Marseille University"

let title = {
  title = "Balancing lists: a proof pearl";
  running_title = Some"Balancing lists"
}

let authors = [
  { name = "Guyslain Naves";
    email = "arnaud@spiwack.net";
    institution = inria;
    running_name = None
  };
  { name = "Arnaud Spiwack";
    email = "guyslain.naves@lif.univ-mrs.fr";
    institution = amu;
    running_name = None
  };
]

let packages = [
  "inputenc" , "utf8" ;
  "fontenc" , "T1" ;
  "textcomp", "";
  "microtype" , "" ;
]

let prelude = concat_with_sep [
  usepackage "hyperref";
  command \"bibliographystyle\" [T,"splncs"] T;
] par

let file = \"fulltrees.tex\"

let _ = emit ~file (document
                             ~title
                             ~authors
                             ~abstract
                             ~prelude
                             ~packages
                             d)

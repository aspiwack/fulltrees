(* -*- compile-command: "ocamlbuild -classic-display fulltrees.pdf" -*- *)

open Prelude
open Ocamlmode


##plugin coqdoc
##verbatim '@' = coqdoc
##verbatim '#' = ocaml_code

(*** labels ***)

let s_algo = label ()
let s_ocaml = label ()
let s_coq = label ()

(*** doc ***)
let abstract = "Starting with an algorithm to turn lists into full trees which uses non-obvious invariants and partial functions, we progressively encode the invariants in the types of the data, removing most of the burden of a correctness proof."

let intro = "{section"Introduction"}

Starting with a list <#l#>, we want to turn it into a binary tree <#t#> of the following form (in OCaml):

{display"<#type 'a tree =
  | Node of 'a tree * 'a * 'a tree
  | Leaf#>"}

With the constraints that <#l#> must be the infix traversal of <#t#> and that <#t#> must be {emph"full"}, in the sense that every level except the last are required to be completely filled. Such a function turns, in particular, sorted list into balanced binary search trees.

There is a number of algorithms to achieve this result in linear time. Here we consider an algorith, presented in Section~{ref_ s_algo}, which repeatedly pairs up trees of height $h$ in a list to form a list of trees of height $h+1$. Our interest in this algorithm sprouts from the fact that its correctness is not obvious; in particular the invariants are complex: the main loop operates on a list of size $2^n-1$ whose elements are full trees whose height is alternatively a given $h$ and $1$.

In Sections~{ref_ s_ocaml} and~{ref_ s_coq} we show refinements of the algorithm where the invariants are pushed into the types, leading to a complete and short proof of correctness in Coq.
"

let algo = "{section"A balancing algorithm" ~label:s_algo}
Sample Ocaml code:
\\
<#let f x = x+3 in
  match f 2 with
  | 3 -> true
  | false#>
"

let ocaml = "{section"Removing partial functions" ~label:s_ocaml}

(* arnaud: make more precise when the previous section is written and has names for things *)
(* arnaud: it's not entirely true that the size invariant is preserved during the main loop, it is an invariant of the external "pass" loop, but not the internal "paring" loop, which certainly does not make things easier. *)
The functions of Section~{ref_ s_algo} rely on the facts that the following invariant hold throughout the main loop: the list has size $2^n-1$ for some $n$ and is non-empty, and all the even position elements (counting from $1$) are singleton trees.

Yet it is not immediately apparent that these properties hold. If it does not take a tremendous effort to convince oneself that the <#balance#> function of Section~{ref_ s_algo} is indeed correct, a direct mechanically checked proof would not be very practical.

{subsection"Size invariants"}

Let us turn to representing non-empty lists of size $2^n-1$. There is a well-known data structure which holds $2^n-1$ values: complete binary trees of height $n$. But given that trees are already what our algorithm builds, it is unlikely that complete binary trees are the appropriate structure for the loop.

Instead, let us consider the following recursive definition of $2^n-1$:
{displaymath begin just_left `Brace (array [`L;`L;`L] [
  array_line [$2^1-1$; $=$ ; $1$];
  array_line [${exponent $2$ $n+1$}-1$; $=$; $2*(2^n-1)+1$];
]) end}
We can use these equations to define, recursively, the {exponent $a$ $2^n-1$}:
{displaymath begin just_left `Brace (array [`L;`L;`L] [
  array_line [exponent $a$ $2^1-1$; $=$ ; $a$];
  array_line [exponent $a$ ${exponent $2$ $n+1$}-1$; $=$; $a*{exponent $(a^2)$ $2^n-1$}$];
]) end}
These equations, can also be read as a recursive definition of the $2^n-1$-th power of a type <#'a#>, {emph"i.e."} lists of length <#n#>, which we can translate into a (non-uniformly recursive) datatype:
{display"<#module PowerList = struct

  type 'a t =
    | One of 'a
    | TwicePlusOne of 'a * ('a*'a) t

end#>"}

Such a type is in the spirit of Okasaki's {emph"numerical representation"}~{cite"Okasaki1999"}(*arnaud: add relevant chapters*) variants of lists. In fact, this very type appears in~{cite"Okasaki1999"} as an pedagogical introduction to more general purpose types.

Although <#'a PowerList.t#> may look like a type of trees, it is not a very accurate depiction. The easiest way to picture how <#'a PowerList.t#> works is to see <#TwicePlusOne#> as a fancy <#(::)#>, then the lists with, respectively, $1$, $3$, $7$, and $15$ elements are as follows:
{itemize [
  "<#[1]#>";
  "<#[1;(2,3)]#>";
  "<#[1;(2,3);((4,5),(6,7))]#>";
  "<#[1;(2,3);((4,5),(6,7));(((8,9),(10,11)),((12,13),(14,15)))]#>";
 ]}
Elements appear in order, like in a list, but they are packed twice as tightly after each <#TwicePlueOne#>.

Just like with regular lists, there is a {emph"map"} function for <#'a PowerList.t#>. Due to the non-uniformity it is a little trickier{footnote"The type annotation on <#PowerList.map#> informs Ocaml that <#map#> is a non-uniform recursive function. Without the type annotation, Ocaml simply assumes that <#map#> is uniformly recursive and fails to typecheck since <#f#> and <#f'#> have different types."} than the regular list map: in the recursive steps, the argument function <#f#> needs to process two consecutive elements at a time.
{display"<#module PowerList = struct

  #{ldots}#

  let rec map : 'a 'b. ('a->'b) -> 'a t -> 'b t = fun f l ->
    match l with
    | One x -> One (f x)
    | TwicePlusOne (x,l) ->
        let f' (x,y) = f x , f y in
        TwicePlusOne ( f x , map f' l)

end#>"}

{subsection"Alternation"}

In Section~{ref_ s_algo}, we encode elements as singleton trees, relying on the <#root#> function to extract the value from the tree. If the invariant that even-position element are actually singleton, <#root#> can fail if the applied to an empty tree, or lose elements if applied to a bigger tree.

In this section, instead, we consider a variant of <#'a PowerList.t#> where every odd position is a tree, and every even position an element. More generally, we define a type <#('odd,'even) AlternatingPowerList.t#> where odd positions have type <#'odd#>, and even positions have type <#'even#>. Such a list should have the following pattern:
{itemize [
  "<#['odd;('even,'odd);(('even,'odd),('even,'odd))#>";
]}
After the first element, which must have type <#'odd#>, there is no difference between even and <#'odd#> position: indeed, removing the first element, we actually have an <#('even*'odd) PowerList.t#>. Hence the definition:
{display"<#module AlternatingPowerList = struct
  type ('odd,'even) t =
    | One of 'odd
    | TwicePlusOne of 'odd * ('even*'odd) PowerList.t

end#>"}

We can now define the main loop of our algorithm. The important remark is that in Section~{ref_ s_algo}, the elements are processed four by four: three are joined into a tree, and the last is left as a future root. After two constructors, the elements of an <#('odd,'even) AlternatingPowerList.t#> are grouped by four: an <#('odd,'even) AlternatingPowerList.t#> of length ${exponent $2$ $n+2$}-1$ is -- abusing notations a little -- of the form <#TwicePlusOne a (TwicePlusOne (b,c) l#>, where <#l#> has type <#(('even*'odd)*('even*'odd)) PowerList.t#>. As a consequence, the inner loop is essentially a <#PowerList.map#>.

Writing <#PL#> and <#APL#> for <#PowerList#> and <#AlternatingPowerList#> respectively, we define the function <#pass:'a tree -> ('a*'a tree) PL.t -> ('a tree,'a) APL.t#>, which joins the trees in a list of length ${exponent $2$ $n+1$}-1$ (represented as the two arguments of the <#TwicePlusOne#> constructor), producing a list of length $2^n-1$, and the function <#balance_powerlist:('a tree,'a) APL.t -> 'a tree#> which iterates <#pass#> until there is a single tree left and returns it:
{display"<#let pass t l =
    match l with
    | PL.One (a,s) -> APL.One (Node(t,a,s))
    | PL.TwicePlusOne((a,s),l) ->
        APL.TwicePlusOne ( Node(t,a,s) ,
                           PL.map (fun ((a,t),(b,s)) -> a , Node(t,b,s) ) l )

let rec balance_powerlist = function
  | APL.One t -> t
  | APL.TwicePlusOne (t,l) ->
      balance_powerlist (pass t l)#>"}

{subsection"Padding"}
"

let coq = "{section"Turning to Coq" ~label:s_coq}
Sample Coq code:
\\
<@Fixpoint f (x:nat) : nat :=
  match x with
  | 0 => 0
  | S x' => f x' end@>
"

let concl = "{section"Conclusion"}

The <@balance@> function of Section~{ref_ s_coq} is, by virtue of its type alone, a total function which turns lists into full binary trees. Yet, to the cost of using intermediary data-structures, it effectively implements the algorithm of Section~{ref_ s_algo}.

The missing piece is to prove that the prefix traversal of <@balance l@> is indeed <@l@>. The prefix traversal of a (full) tree is represented in Coq with the functions
{display"<@Fixpoint list_of_full_tree_n {A n} (t:FullTree A n) : list A :=
  match t with
  | Leaf₀ => []
  | Leaf₁ => []
  | Node _ t₁ x t₂ => list_of_full_tree_n t₁ ++ [x] ++ list_of_full_tree_n t₂
  end
.

Definition list_of_full_tree {A} (t:{ n:nat & FullTree A n }) : list A :=
  list_of_full_tree_n (projT2 t)
.@>"}
We can then state the theorem:
{display"<@Theorem balance_preserves_order A (l:list A) : list_of_full_tree (balance l) = l.@>"}

The proof is short and straightforward: we define a traversal function for each intermediate structure and state a variant of <@balance_preserves_order@> for each intermediate function. Proving the intermediate lemmas is not difficult and can be mostly automatised: we use a very simple generic automated tactic, which discharges most goals. This theorem concludes our easy formal proof of the balancing algorithm.
"

let d = concat [
  intro;
  algo;
  ocaml;
  coq;
  concl;
  command \"bibliography\" [A,"library"] A;
]

(*** metadata ***)

open Llncs

let inria = new_institution "Inria Paris-Rocquencourt\\{textsc"Ens"}, 45 rue d'Ulm,
 75230 Paris Cedex 05, France"
let amu = new_institution "Aix-Marseille University"

let title = {
  title = "Balancing lists: a proof pearl";
  running_title = Some"Balancing lists"
}

let authors = [
  { name = "Guyslain Naves";
    email = "arnaud@spiwack.net";
    institution = inria;
    running_name = None
  };
  { name = "Arnaud Spiwack";
    email = "guyslain.naves@lif.univ-mrs.fr";
    institution = amu;
    running_name = None
  };
]

let packages = [
  "inputenc" , "utf8" ;
  "fontenc" , "T1" ;
  "textcomp", "";
  "microtype" , "" ;
]

let prelude = concat_with_sep [
  usepackage "hyperref";
  command \"bibliographystyle\" [T,"splncs"] T;
] par

let file = \"fulltrees.tex\"

let _ = emit ~file (document
                             ~title
                             ~authors
                             ~abstract
                             ~prelude
                             ~packages
                             d)

(* -*- compile-command: "ocamlbuild -classic-display navesspiwack.pdf"  -*- *)

open Mlpost
open Latex
open Slides.Iterator
open Prelude

##plugin coqdoc
##verbatim '@' = coqdoc
##verbatim '#' = ocaml_code


let prelude = concat_with_sep [
  input "style.tex";
  color_prelude;
] par

let packages = [
  "inputenc" , "utf8" ;
]

(** printing the intermediate structures of the algorithm with mlpost *)

type 'a tree =
| Node of 'a tree * 'a * 'a tree
| Leaf
| Leaf1

type 'a alt =
| Pivot of bool*'a (** [true] if selected for next step *)
| Tree of 'a tree

module Algo = struct

  open Mlpost

  (** parameters *)
  let bsize = Num.cm 0.7
  let height = bsize
  let width = bsize
  let textsize = large3
  let treesep = Num.cm 0.7
  let treebase_color = Color.mediumgray

  (** basic boxes *)
  let emptyb ?fill () =
    Box.empty ?fill ~height ~width ()
  let numb ?fill i =
    let i' = textsize (mode M (latex_of_int i)) in
    let () = Format.printf \"%s@.\" (Latex.to_string i') in
    let i'' = Melt.picture_of_latex i' in
    Box.pic ?fill i''

  (** Make all boxes the same size then draw their borders. *)
  let normalize l =
    Box.same_height (Box.same_width l) |>
    List.map (fun b -> Box.rect ~dx:0. ~dy:0. b) |>
    List.map begin fun b ->
      match Box.get_fill (Box.nth 0 b) with
      | None -> b
      | Some c -> Box.set_fill c b
    end

  (** Draws a list of numbers. *)
  let pr_int_list l =
    emptyb ()::List.map numb l |>
    normalize |> (* uses emptyb to normalize the box size. *)
    List.tl |>
    Box.hbox

  (** Draws a tree bottom up *)
  let rec tree_height = function
    | Leaf -> 0
    | Leaf1 -> 1
    | Node (l,_,r) -> 1+max (tree_height l) (tree_height r)

  let rec expint a = function
    | 0 -> 1
    | n when n mod 2 = 0 -> expint (a*a) (n/2)
    | n -> a*(expint (a*a)) (n/2)

  let base_size t =
    let h = tree_height t in
    (expint 2 h) - 1

  let rec tree_map f = function
    | Node(l,x,r) -> Node (tree_map f l , f x , tree_map f r)
    | Leaf -> Leaf
    | Leaf1 -> Leaf1

  (* precondition: [base_size t = List.length ps] *)
  let assign_base_depth ps t =
    assert (base_size t = List.length ps);
    let push x (l,y,r) = (x::l,y,r) in
    let rec split_at n = function
      | a::l when n > 0 -> push a (split_at (n-1) l)
      | a::l when n = 0 -> ([],a,l)
      | _ -> assert false
    in
    let rec assign_base_depth ps size d = function
      | Node (l,x,r) ->
        let hsize = (size - 1)/2 in
        let (pl,a,pr) = split_at hsize ps in
        Node (
          assign_base_depth pl hsize (d+1) l ,
          (a,d,x) ,
          assign_base_depth pr hsize (d+1) r )
      | Leaf -> Leaf
      | Leaf1 -> Leaf1
    in
    assign_base_depth ps (base_size t) 0 t

  let pr_int_tree ps t =
    let at = assign_base_depth ps t in
    let h = tree_height t in
    let pos_of_bd p d =
      let height = h - d in
      Point.shift p Point.(mult (Num.multf (float_of_int height) treesep) up)
    in
    let placed_t =
      tree_map begin fun (p,d,x) ->
        numb x |>
        Box.center (pos_of_bd p d)
      end at
    in
    let arrow_style = Arrow.(add_line empty) in
    (** [p] is the parent box *)
    let rec draw_arrows p = function
      | Leaf1 -> Command.nop
      | Leaf -> Command.nop
      | Node (l,x,r) ->
        let open Command in
        draw_arrows x l ++
        Arrow.box_to_box ~kind:arrow_style p x ++
        draw_arrows x r
    in
    let arrows =
      match placed_t with
      | Leaf -> Command.nop
      | Leaf1 -> Command.nop
      | Node (l,x,r) -> Command.(draw_arrows x l ++ draw_arrows x r)
    in
    let rec draw_boxes = function
      | Leaf -> Command.nop
      | Leaf1 -> Command.nop
      | Node (l,x,r) ->
        let open Command in
        draw_boxes l ++
        Box.draw x ++
        draw_boxes r
    in
    Command.(draw_boxes placed_t ++ arrows)

  let pr_alt_list l =
    let rec genempty n =
      if n = 0 then []
      else (emptyb ~fill:treebase_color ()) :: genempty (n-1)
    in
    let rec gen_base = function
      | Pivot (b,i) :: l ->
        let (r,q) = gen_base l in
        let fill =
          if b then Some Color.lightblue
          else None
        in
        numb ?fill i ::r , q
      | Tree t :: l ->
        let tq = genempty(base_size t) in
        let (r,q) = gen_base l in
        tq @ r , (t,tq)::q
      | [] -> [],[]
    in
    let (base,queue) = gen_base l in
    let base =
      normalize (base) |>
      Box.hbox
    in
    let trees =
      List.map begin fun (t,q) ->
        let ps =
          List.map begin fun b ->
            Box.ctr (Box.sub b base)
          end q
        in
        pr_int_tree ps t
      end queue
    in
    let open Command in
    Box.draw base ++
    seq trees

    (** The actual algorithm, in an incremental fashion *)

    (* mostly duplicated from [simple.ml] *)

    type state =
    | Init of int list
    | Unmarked of int alt list (** inv bools are all false *)
    | Marked of int alt list

    let pr_state = function
      | Init l -> Box.draw (pr_int_list l)
      | Unmarked l | Marked l -> pr_alt_list l

    let join l x r = Tree(Node(l,x,r))

    let complete list =
      let n = List.length list in
      let rec pow2 i = if i <= n then pow2 (2*i) else i in
      let missing = (pow2 1) - n - 1 in
      let rec pad missing = function
        | head::tail when missing <> 0 -> Tree Leaf1 :: Pivot (false,head) :: pad (missing - 1) tail
        | odd::even::others -> join Leaf odd Leaf :: Pivot(false,even) :: pad 0 others
        | [single] -> [join Leaf single Leaf]
        | [] -> []
      in
      pad missing list

    let rec select = function
      | Tree left :: Pivot (false,root) :: Tree right :: Pivot (false,e) :: others ->
        Tree left :: Pivot (true,root) :: Tree right :: Pivot (false,e) :: select others
      | [Tree left ; Pivot (false,root) ; Tree right] ->
        [Tree left ; Pivot (true,root) ; Tree right]
      | _ -> assert false

    let rec pass = function
      | Tree left :: Pivot (true,root) :: Tree right :: Pivot (false,e) :: others ->
        join left root right :: Pivot (false,e) :: pass others
      | [Tree left; Pivot (true,root); Tree right] -> [join left root right]
      | _ -> assert false

    let step = function
      | Init l -> Some (Unmarked (complete l))
      | Unmarked [Tree _] -> None
      | Unmarked l -> Some (Marked (select l))
      | Marked l -> Some (Unmarked (pass l))

    let run l =
      let rec run = function
        | None -> []
        | Some s -> s::(run (step s))
      in
      run (Some (Init l))

    let put_frame ?logo ?title l =
      let seq = list (run l) in
      let the_frame q =
        center (rule_ (`Pt 0.) (`Textwidth 0.5) ^^ mlpost (pr_state q))
      in
      put seq (frame ?logo ?title the_frame)

end

(** /algo *)



let doc = ([
  title_put (list [1]) begin title_frame (fun _ ->
    textbf (huge2 "Balancing lists" ^^ newline ^^ large3"A proof pearl")
          ^^ newline_size (`Mm 6.) ^^ large2"Guyslain Naves \& Arnaud Spiwack"
  )end;

  put (list[1]) begin frame ~title:"Have you read this book?" (fun _ ->
    center (includegraphics ~height:Slides.(unit (height*.0.75)) "okasaki.png")
  )end;

  put (list[1]) begin frame ~title:"Lists as exponentiation" (fun _ ->
    "List of size $n$: type exponentiation $A^n$
     {displaymath (just_left `Brace (array [`L;`L;`L] [
       array_line [$A^0$;$=$;$1$];
       array_line [exponent$A$ $n+1$;$=$;$A{times}A^n$];
     ]))}{newline_size(`Mm 4.)}

     Example:
     {displaymath$[1;2;3;4;5;6;7;8;9;10;11]$}"
  )end;

  put (list[1]) begin frame ~title:"Lists as fast exponentiation" (fun _ ->
    "List of size $n$: still type exponentiation $A^n$
     {displaymath (just_left `Brace (array [`L;`L;`L] [
       array_line [$A^0$;$=$;$A$];
       array_line [exponent$A$ $2n$;$=$;$(A{times}A)^n$];
       array_line [exponent$A$ $2n+1$;$=$;$A{times}(A{times}A)^n$];
     ]))}{newline_size(`Mm 4.)}

     Example ($11 = {overline$1101$}^2$):
     {let thin = text\"\\\\,\" in
       displaymath$[1;(2,3);{thin^^cdot^^thin};(((4,5),(6,7)),((8,9),(10,11)))]$}"
  )end;

  put (list[1]) begin frame ~title:"Binary list datatype" (fun _ ->
    "{array [`L;`Vert;`L;`L] [
      array_line ~layout:[3,`L] ["<@Inductive BList (A:Type) : Type :=@>"];
      array_line ["";"<@zero@>";""];
      array_line ["";"<@twice@>";"<@(l:BList (A*A))@>"];
      array_line ["";"<@tpo@>";"<@(a:A) (l:BList (A*A)).@>"];
    ]}"
  )end;

  Algo.put_frame ~title:"From list to trees" [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15];

  Algo.put_frame  ~title:"Fill up to {exponent$2$$n-1$}" [1;2;3;4;5;6;7;8;9;10;11];

])


let file = \"navesspiwack.tex\"

let _ = emit ~file 
             (Slides.document ~prelude ~packages doc)
  (* arnaud: rafiner les modes plus tard *)

let _ =
  let s = Metapost_tool.read_prelude_from_tex_file file  in
  Defaults.set_prelude s

let _ =
  Defaults.set_required_files [
    \"style.tex\"
  ]

let _ = match Arg.mode with
	 | `Cairo -> Cairost.dump_pdf ()
	 | `Mps -> Mps.dump ()
	 | _ -> assert false
